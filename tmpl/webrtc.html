<!DOCTYPE html>
<html>
<head>
	<title>WebRTC</title>
	
	<script src="static/lib/util.js"></script>
	
	<style>
	video {
		/* filter: hue-rotate(180deg) saturate(200%);
		-moz-filter: hue-rotate(180deg) saturate(200%);
		-webkit-filter: hue-rotate(180deg) saturate(200%); */
	}
	</style>
</head>
<body>
	<h1>Hello World</h1>
	<video id="localvideo"></video>

<script type="text/javascript">

if (navigator.mozGetUserMedia) {
  navigator.getUserMedia = navigator.mozGetUserMedia;
  RTCPeerConnection = mozRTCPeerConnection;
} else {
  navigator.getUserMedia = navigator.webkitGetUserMedia;
  RTCPeerConnection = webkitRTCPeerConnection;
}

var controllerData = {{.}};
var members = controllerData["Members"];
console.log("members in room", members);

mediaConstraints = {video: true};

function sendSignal(destinations, message) {
  var body = JSON.stringify(message);
  var data = {"destinations": destinations, "body": body}
  console.log('C->S: ', data);

  var xhr = new XMLHttpRequest();
  xhr.open('POST', '/webrtc/signal/transmitter', true);
  xhr.send(JSON.stringify(data));
}

var g_RTCPeerConnections = {};
function preparePeerConnection(myToken, token, onaddstream) {
  var pc_config = {"iceServers": [{"url": "stun:stun.l.google.com:19302"}]};
  var onicecandidate = function(evt) {
    if (!evt.candidate){
      return;
    } // End of candidates reported by browser.
    var msg = {"from": myToken,
               "type": "icecandidate",
               "candidate": evt.candidate.candidate,
               "sdpMLineIndex": evt.candidate.sdpMLineIndex,
               "sdpMid": evt.candidate.sdpMid};
    sendSignal([token], msg);
  };
  
  pc = new RTCPeerConnection(pc_config);
  pc.onicecandidate = onicecandidate;
  pc.onaddstream = onaddstream;
  g_RTCPeerConnections[token] = pc;
  return pc;
}

// evt is expected to be an EventSource event
function rtcSignalHandler(localMediaStream, myToken, evt) {
  var msg = JSON.parse(evt.data);
  console.log(msg);
  var pc = g_RTCPeerConnections[msg.from];
    
  if (msg.type == "offer") {
    if (!pc) {
      pc = preparePeerConnection(myToken, msg.from, onAddRemoteStream);
      pc.addStream(localMediaStream);
    }
    pc.setRemoteDescription(new RTCSessionDescription(msg.sessionDescription));
    var answerSuccessCallback = function(sessionDescription) {
      pc.setLocalDescription(sessionDescription,
                             function(evt){},
                             function(err){ console.log(err); });
      var answerMsg = {"from": myToken,
                       "type": "answer",
                       "sessionDescription": sessionDescription};
      sendSignal([msg.from], answerMsg);
    };
    pc.createAnswer(answerSuccessCallback,
                    function(err){ console.log(err); });
                      
  } else if (msg.type == "answer") {
    if (!pc) { return; }
    pc.setRemoteDescription(new RTCSessionDescription(msg.sessionDescription));
      
  } else if (msg.type == "icecandidate") {
    if (!pc) { return; }
    var candidate = new RTCIceCandidate({"candidate": msg.candidate,
                                         "sdpMLineIndex": msg.sdpMLineIndex});
    pc.addIceCandidate(candidate);
      
  } else {
    console.log("Unknown message: ", msg);
  }
}

// pc is a RTCPeerConnection 
function createSignalChannel(callback) {
  var source = new EventSource("/webrtc/signal/source");
  var myTokenListener = function(evt) {
    var msg = JSON.parse(evt.data);
    console.log(msg);
    var pc = g_RTCPeerConnections[msg.from];
    
    if (msg.type == "token") {
      var myToken = msg.token;
      callback(source, myToken);
      source.removeEventListener("message", myTokenListener, false);
      console.log("my token: ", myToken);
      
    } else {
      console.log("Unknown message: ", msg);
    }
  }
  source.addEventListener("message", myTokenListener, false);
  return source;
}

// pc is a RTCPeerConnection
function getLocalMedia(callback) {
  function getUserMediaSuccess(localMediaStream) {
    window.localMediaStream = localMediaStream;
    var video = document.querySelector("#localvideo");
    video.src = window.URL.createObjectURL(localMediaStream);
    video.play();
    
    callback(localMediaStream);
  }
  function getUserMediaError(error){
    console.log("navigator.getUserMedia error: ", error);
  }
  navigator.getUserMedia(mediaConstraints, getUserMediaSuccess, getUserMediaError);
}

function onAddRemoteStream(evt){
  var remotevideo = document.createElement("video");
  remotevideo.src = URL.createObjectURL(evt.stream);
  remotevideo.style.width = "50%";
  
  localvideo = document.querySelector("#localvideo");
  localvideo.parentNode.insertBefore(remotevideo, localvideo);
  
  g_remoteStream = evt.stream;
  g_remoteVideo = remotevideo;
};

createSignalChannel(function(source, myToken) {
  for (var i = 0; i != members.length; i++) {
    var token = members[i];
    preparePeerConnection(myToken, token, onAddRemoteStream);
  }
  
  getLocalMedia(function(localMediaStream){
    source.addEventListener("message", function(evt){
      rtcSignalHandler(localMediaStream, myToken, evt);
    });
  
    for (var i = 0; i != members.length; i++) {
      var token = members[i];
      var pc = g_RTCPeerConnections[token];
      
      pc.addStream(localMediaStream);
      var offerSuccessCallback = function(sessionDescription) {
        pc.setLocalDescription(sessionDescription,
                               function(evt){},
                               function(err){ console.log(err); });
        var msg = {"from": myToken,
                   "type": "offer",
                   "sessionDescription": sessionDescription};
        sendSignal([token], msg);
      };
      pc.createOffer(offerSuccessCallback, function(err){ console.log(err); });
    }
  });
  
  window.onbeforeunload = function(e){
    postHTTP("/webrtc/signal/leave_source",
             {"token": myToken},
             function(data){ console.log(data); },
             false // synchronous HTTP request
             );
  };
});

</script>

</body>
</html>